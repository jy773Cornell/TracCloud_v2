/*! For license information please see vendors-node_modules_mermaid_dist_edges-49ac43a2_js.js.LICENSE.txt */
"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([["vendors-node_modules_mermaid_dist_edges-49ac43a2_js"],{"./node_modules/mermaid/dist/edges-49ac43a2.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ insertMarkers$1),\n/* harmony export */   b: () => (/* binding */ clear$1),\n/* harmony export */   c: () => (/* binding */ createLabel$1),\n/* harmony export */   d: () => (/* binding */ clear),\n/* harmony export */   e: () => (/* binding */ insertNode),\n/* harmony export */   f: () => (/* binding */ insertEdgeLabel),\n/* harmony export */   g: () => (/* binding */ insertEdge),\n/* harmony export */   h: () => (/* binding */ positionEdgeLabel),\n/* harmony export */   i: () => (/* binding */ intersectRect$1),\n/* harmony export */   l: () => (/* binding */ labelHelper),\n/* harmony export */   p: () => (/* binding */ positionNode),\n/* harmony export */   s: () => (/* binding */ setNodeElem),\n/* harmony export */   u: () => (/* binding */ updateNodeBounds)\n/* harmony export */ });\n/* harmony import */ var _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mermaid-b0ad2de1.js */ "./node_modules/mermaid/dist/mermaid-b0ad2de1.js");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "./node_modules/mermaid/node_modules/d3/src/index.js");\n/* harmony import */ var _createText_3df630b5_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createText-3df630b5.js */ "./node_modules/mermaid/dist/createText-3df630b5.js");\n/* harmony import */ var _svgDraw_0fcc813d_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./svgDraw-0fcc813d.js */ "./node_modules/mermaid/dist/svgDraw-0fcc813d.js");\n\n\n\n\nconst insertMarkers = (elem, markerArray, type, id) => {\n  markerArray.forEach((markerName) => {\n    markers[markerName](elem, type, id);\n  });\n};\nconst extension = (elem, type, id) => {\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.trace("Making markers for ", id);\n  elem.append("defs").append("marker").attr("id", type + "-extensionStart").attr("class", "marker extension " + type).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");\n  elem.append("defs").append("marker").attr("id", type + "-extensionEnd").attr("class", "marker extension " + type).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");\n};\nconst composition = (elem, type) => {\n  elem.append("defs").append("marker").attr("id", type + "-compositionStart").attr("class", "marker composition " + type).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n  elem.append("defs").append("marker").attr("id", type + "-compositionEnd").attr("class", "marker composition " + type).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n};\nconst aggregation = (elem, type) => {\n  elem.append("defs").append("marker").attr("id", type + "-aggregationStart").attr("class", "marker aggregation " + type).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n  elem.append("defs").append("marker").attr("id", type + "-aggregationEnd").attr("class", "marker aggregation " + type).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");\n};\nconst dependency = (elem, type) => {\n  elem.append("defs").append("marker").attr("id", type + "-dependencyStart").attr("class", "marker dependency " + type).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");\n  elem.append("defs").append("marker").attr("id", type + "-dependencyEnd").attr("class", "marker dependency " + type).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");\n};\nconst lollipop = (elem, type) => {\n  elem.append("defs").append("marker").attr("id", type + "-lollipopStart").attr("class", "marker lollipop " + type).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "white").attr("cx", 6).attr("cy", 7).attr("r", 6);\n};\nconst point = (elem, type) => {\n  elem.append("marker").attr("id", type + "-pointEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 10).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n  elem.append("marker").attr("id", type + "-pointStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 0).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n};\nconst circle$1 = (elem, type) => {\n  elem.append("marker").attr("id", type + "-circleEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n  elem.append("marker").attr("id", type + "-circleStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");\n};\nconst cross = (elem, type) => {\n  elem.append("marker").attr("id", type + "-crossEnd").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");\n  elem.append("marker").attr("id", type + "-crossStart").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");\n};\nconst barb = (elem, type) => {\n  elem.append("defs").append("marker").attr("id", type + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");\n};\nconst markers = {\n  extension,\n  composition,\n  aggregation,\n  dependency,\n  lollipop,\n  point,\n  circle: circle$1,\n  cross,\n  barb\n};\nconst insertMarkers$1 = insertMarkers;\nfunction applyStyle(dom, styleFn) {\n  if (styleFn) {\n    dom.attr("style", styleFn);\n  }\n}\nfunction addHtmlLabel(node) {\n  const fo = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"));\n  const div = fo.append("xhtml:div");\n  const label = node.label;\n  const labelClass = node.isNode ? "nodeLabel" : "edgeLabel";\n  div.html(\n    \'<span class="\' + labelClass + \'" \' + (node.labelStyle ? \'style="\' + node.labelStyle + \'"\' : "") + ">" + label + "</span>"\n  );\n  applyStyle(div, node.labelStyle);\n  div.style("display", "inline-block");\n  div.style("white-space", "nowrap");\n  div.attr("xmlns", "http://www.w3.org/1999/xhtml");\n  return fo.node();\n}\nconst createLabel = (_vertexText, style, isTitle, isNode) => {\n  let vertexText = _vertexText || "";\n  if (typeof vertexText === "object") {\n    vertexText = vertexText[0];\n  }\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    vertexText = vertexText.replace(/\\\\n|\\n/g, "<br />");\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("vertexText" + vertexText);\n    const node = {\n      isNode,\n      label: (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.H)(vertexText).replace(\n        /fa[blrs]?:fa-[\\w-]+/g,\n        (s) => `<i class=\'${s.replace(":", " ")}\'></i>`\n      ),\n      labelStyle: style.replace("fill:", "color:")\n    };\n    let vertexNode = addHtmlLabel(node);\n    return vertexNode;\n  } else {\n    const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");\n    svgLabel.setAttribute("style", style.replace("color:", "fill:"));\n    let rows = [];\n    if (typeof vertexText === "string") {\n      rows = vertexText.split(/\\\\n|\\n|<br\\s*\\/?>/gi);\n    } else if (Array.isArray(vertexText)) {\n      rows = vertexText;\n    } else {\n      rows = [];\n    }\n    for (const row of rows) {\n      const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");\n      tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");\n      tspan.setAttribute("dy", "1em");\n      tspan.setAttribute("x", "0");\n      if (isTitle) {\n        tspan.setAttribute("class", "title-row");\n      } else {\n        tspan.setAttribute("class", "row");\n      }\n      tspan.textContent = row.trim();\n      svgLabel.appendChild(tspan);\n    }\n    return svgLabel;\n  }\n};\nconst createLabel$1 = createLabel;\nconst labelHelper = async (parent, node, _classes, isNode) => {\n  let classes;\n  const useHtmlLabels = node.useHtmlLabels || (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels);\n  if (!_classes) {\n    classes = "node default";\n  } else {\n    classes = _classes;\n  }\n  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);\n  const label = shapeSvg.insert("g").attr("class", "label").attr("style", node.labelStyle);\n  let labelText;\n  if (node.labelText === void 0) {\n    labelText = "";\n  } else {\n    labelText = typeof node.labelText === "string" ? node.labelText : node.labelText[0];\n  }\n  const textNode = label.node();\n  let text;\n  if (node.labelType === "markdown") {\n    text = (0,_createText_3df630b5_js__WEBPACK_IMPORTED_MODULE_2__.c)(label, (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.d)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.H)(labelText), (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)()), {\n      useHtmlLabels,\n      width: node.width || (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.wrappingWidth,\n      classes: "markdown-node-label"\n    });\n  } else {\n    text = textNode.appendChild(\n      createLabel$1(\n        (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.d)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.H)(labelText), (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)()),\n        node.labelStyle,\n        false,\n        isNode\n      )\n    );\n  }\n  let bbox = text.getBBox();\n  const halfPadding = node.padding / 2;\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(text);\n    const images = div.getElementsByTagName("img");\n    if (images) {\n      const noImgText = labelText.replace(/<img[^>]*>/g, "").trim() === "";\n      await Promise.all(\n        [...images].map(\n          (img) => new Promise(\n            (res) => img.addEventListener("load", function() {\n              img.style.display = "flex";\n              img.style.flexDirection = "column";\n              if (noImgText) {\n                const bodyFontSize = (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().fontSize ? (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().fontSize : window.getComputedStyle(document.body).fontSize;\n                const enlargingFactor = 5;\n                img.style.width = parseInt(bodyFontSize, 10) * enlargingFactor + "px";\n              } else {\n                img.style.width = "100%";\n              }\n              res(img);\n            })\n          )\n        )\n      );\n    }\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  if (useHtmlLabels) {\n    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");\n  } else {\n    label.attr("transform", "translate(0, " + -bbox.height / 2 + ")");\n  }\n  if (node.centerLabel) {\n    label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");\n  }\n  label.insert("rect", ":first-child");\n  return { shapeSvg, bbox, halfPadding, label };\n};\nconst updateNodeBounds = (node, element) => {\n  const bbox = element.node().getBBox();\n  node.width = bbox.width;\n  node.height = bbox.height;\n};\nfunction insertPolygonShape(parent, w, h, points) {\n  return parent.insert("polygon", ":first-child").attr(\n    "points",\n    points.map(function(d) {\n      return d.x + "," + d.y;\n    }).join(" ")\n  ).attr("class", "label-container").attr("transform", "translate(" + -w / 2 + "," + h / 2 + ")");\n}\nfunction intersectNode(node, point2) {\n  return node.intersect(point2);\n}\nfunction intersectEllipse(node, rx, ry, point2) {\n  var cx = node.x;\n  var cy = node.y;\n  var px = cx - point2.x;\n  var py = cy - point2.y;\n  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);\n  var dx = Math.abs(rx * ry * px / det);\n  if (point2.x < cx) {\n    dx = -dx;\n  }\n  var dy = Math.abs(rx * ry * py / det);\n  if (point2.y < cy) {\n    dy = -dy;\n  }\n  return { x: cx + dx, y: cy + dy };\n}\nfunction intersectCircle(node, rx, point2) {\n  return intersectEllipse(node, rx, rx, point2);\n}\nfunction intersectLine(p1, p2, q1, q2) {\n  var a1, a2, b1, b2, c1, c2;\n  var r1, r2, r3, r4;\n  var denom, offset, num;\n  var x, y;\n  a1 = p2.y - p1.y;\n  b1 = p1.x - p2.x;\n  c1 = p2.x * p1.y - p1.x * p2.y;\n  r3 = a1 * q1.x + b1 * q1.y + c1;\n  r4 = a1 * q2.x + b1 * q2.y + c1;\n  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {\n    return;\n  }\n  a2 = q2.y - q1.y;\n  b2 = q1.x - q2.x;\n  c2 = q2.x * q1.y - q1.x * q2.y;\n  r1 = a2 * p1.x + b2 * p1.y + c2;\n  r2 = a2 * p2.x + b2 * p2.y + c2;\n  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {\n    return;\n  }\n  denom = a1 * b2 - a2 * b1;\n  if (denom === 0) {\n    return;\n  }\n  offset = Math.abs(denom / 2);\n  num = b1 * c2 - b2 * c1;\n  x = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  num = a2 * c1 - a1 * c2;\n  y = num < 0 ? (num - offset) / denom : (num + offset) / denom;\n  return { x, y };\n}\nfunction sameSign(r1, r2) {\n  return r1 * r2 > 0;\n}\nfunction intersectPolygon(node, polyPoints, point2) {\n  var x1 = node.x;\n  var y1 = node.y;\n  var intersections = [];\n  var minX = Number.POSITIVE_INFINITY;\n  var minY = Number.POSITIVE_INFINITY;\n  if (typeof polyPoints.forEach === "function") {\n    polyPoints.forEach(function(entry) {\n      minX = Math.min(minX, entry.x);\n      minY = Math.min(minY, entry.y);\n    });\n  } else {\n    minX = Math.min(minX, polyPoints.x);\n    minY = Math.min(minY, polyPoints.y);\n  }\n  var left = x1 - node.width / 2 - minX;\n  var top = y1 - node.height / 2 - minY;\n  for (var i = 0; i < polyPoints.length; i++) {\n    var p1 = polyPoints[i];\n    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];\n    var intersect2 = intersectLine(\n      node,\n      point2,\n      { x: left + p1.x, y: top + p1.y },\n      { x: left + p2.x, y: top + p2.y }\n    );\n    if (intersect2) {\n      intersections.push(intersect2);\n    }\n  }\n  if (!intersections.length) {\n    return node;\n  }\n  if (intersections.length > 1) {\n    intersections.sort(function(p, q) {\n      var pdx = p.x - point2.x;\n      var pdy = p.y - point2.y;\n      var distp = Math.sqrt(pdx * pdx + pdy * pdy);\n      var qdx = q.x - point2.x;\n      var qdy = q.y - point2.y;\n      var distq = Math.sqrt(qdx * qdx + qdy * qdy);\n      return distp < distq ? -1 : distp === distq ? 0 : 1;\n    });\n  }\n  return intersections[0];\n}\nconst intersectRect = (node, point2) => {\n  var x = node.x;\n  var y = node.y;\n  var dx = point2.x - x;\n  var dy = point2.y - y;\n  var w = node.width / 2;\n  var h = node.height / 2;\n  var sx, sy;\n  if (Math.abs(dy) * w > Math.abs(dx) * h) {\n    if (dy < 0) {\n      h = -h;\n    }\n    sx = dy === 0 ? 0 : h * dx / dy;\n    sy = h;\n  } else {\n    if (dx < 0) {\n      w = -w;\n    }\n    sx = w;\n    sy = dx === 0 ? 0 : w * dy / dx;\n  }\n  return { x: x + sx, y: y + sy };\n};\nconst intersectRect$1 = intersectRect;\nconst intersect = {\n  node: intersectNode,\n  circle: intersectCircle,\n  ellipse: intersectEllipse,\n  polygon: intersectPolygon,\n  rect: intersectRect$1\n};\nconst note = async (parent, node) => {\n  const useHtmlLabels = node.useHtmlLabels || (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels;\n  if (!useHtmlLabels) {\n    node.centerLabel = true;\n  }\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    "node " + node.classes,\n    true\n  );\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Classes = ", node.classes);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  rect2.attr("rx", node.rx).attr("ry", node.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst note$1 = note;\nconst question = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const s = w + h;\n  const points = [\n    { x: s / 2, y: 0 },\n    { x: s, y: -s / 2 },\n    { x: s / 2, y: -s },\n    { x: 0, y: -s / 2 }\n  ];\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Question main (Circle)");\n  const questionElem = insertPolygonShape(shapeSvg, s, s, points);\n  questionElem.attr("style", node.style);\n  updateNodeBounds(node, questionElem);\n  node.intersect = function(point2) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("Intersect called");\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst choice = (parent, node) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  const s = 28;\n  const points = [\n    { x: 0, y: s / 2 },\n    { x: s / 2, y: 0 },\n    { x: 0, y: -s / 2 },\n    { x: -s / 2, y: 0 }\n  ];\n  const choice2 = shapeSvg.insert("polygon", ":first-child").attr(\n    "points",\n    points.map(function(d) {\n      return d.x + "," + d.y;\n    }).join(" ")\n  );\n  choice2.attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28);\n  node.width = 28;\n  node.height = 28;\n  node.intersect = function(point2) {\n    return intersect.circle(node, 14, point2);\n  };\n  return shapeSvg;\n};\nconst hexagon = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const f = 4;\n  const h = bbox.height + node.padding;\n  const m = h / f;\n  const w = bbox.width + 2 * m + node.padding;\n  const points = [\n    { x: m, y: 0 },\n    { x: w - m, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w - m, y: -h },\n    { x: m, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  const hex = insertPolygonShape(shapeSvg, w, h, points);\n  hex.attr("style", node.style);\n  updateNodeBounds(node, hex);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_left_inv_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -h / 2, y: 0 },\n    { x: w, y: 0 },\n    { x: w, y: -h },\n    { x: -h / 2, y: -h },\n    { x: 0, y: -h / 2 }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  node.width = w + h;\n  node.height = h;\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_right = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -2 * h / 6, y: 0 },\n    { x: w - h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: -h },\n    { x: h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst lean_left = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 2 * h / 6, y: 0 },\n    { x: w + h / 6, y: 0 },\n    { x: w - 2 * h / 6, y: -h },\n    { x: -h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst trapezoid = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: -2 * h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: 0 },\n    { x: w - h / 6, y: -h },\n    { x: h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst inv_trapezoid = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: h / 6, y: 0 },\n    { x: w - h / 6, y: 0 },\n    { x: w + 2 * h / 6, y: -h },\n    { x: -2 * h / 6, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst rect_right_inv_arrow = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 0, y: 0 },\n    { x: w + h / 2, y: 0 },\n    { x: w, y: -h / 2 },\n    { x: w + h / 2, y: -h },\n    { x: 0, y: -h }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst cylinder = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const rx = w / 2;\n  const ry = rx / (2.5 + w / 50);\n  const h = bbox.height + ry + node.padding;\n  const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w + " 0 a " + rx + "," + ry + " 0,0,0 " + -w + " 0 l 0," + h + " a " + rx + "," + ry + " 0,0,0 " + w + " 0 l 0," + -h;\n  const el = shapeSvg.attr("label-offset-y", ry).insert("path", ":first-child").attr("style", node.style).attr("d", shape).attr("transform", "translate(" + -w / 2 + "," + -(h / 2 + ry) + ")");\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    const pos = intersect.rect(node, point2);\n    const x = pos.x - node.x;\n    if (rx != 0 && (Math.abs(x) < node.width / 2 || Math.abs(x) == node.width / 2 && Math.abs(pos.y - node.y) > node.height / 2 - ry)) {\n      let y = ry * ry * (1 - x * x / (rx * rx));\n      if (y != 0) {\n        y = Math.sqrt(y);\n      }\n      y = ry - y;\n      if (point2.y - node.y > 0) {\n        y = -y;\n      }\n      pos.y += y;\n    }\n    return pos;\n  };\n  return shapeSvg;\n};\nconst rect = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(\n    parent,\n    node,\n    "node " + node.classes,\n    true\n  );\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const totalWidth = bbox.width + node.padding;\n  const totalHeight = bbox.height + node.padding;\n  rect2.attr("class", "basic label-container").attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", totalWidth).attr("height", totalHeight);\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete("borders");\n    }\n    propKeys.forEach((propKey) => {\n      _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst labelRect = async (parent, node) => {\n  const { shapeSvg } = await labelHelper(parent, node, "label", true);\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.trace("Classes = ", node.classes);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const totalWidth = 0;\n  const totalHeight = 0;\n  rect2.attr("width", totalWidth).attr("height", totalHeight);\n  shapeSvg.attr("class", "label edgeLabel");\n  if (node.props) {\n    const propKeys = new Set(Object.keys(node.props));\n    if (node.props.borders) {\n      applyNodePropertyBorders(rect2, node.props.borders, totalWidth, totalHeight);\n      propKeys.delete("borders");\n    }\n    propKeys.forEach((propKey) => {\n      _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`Unknown node property ${propKey}`);\n    });\n  }\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nfunction applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {\n  const strokeDashArray = [];\n  const addBorder = (length) => {\n    strokeDashArray.push(length, 0);\n  };\n  const skipBorder = (length) => {\n    strokeDashArray.push(0, length);\n  };\n  if (borders.includes("t")) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add top border");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes("r")) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add right border");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  if (borders.includes("b")) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add bottom border");\n    addBorder(totalWidth);\n  } else {\n    skipBorder(totalWidth);\n  }\n  if (borders.includes("l")) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.debug("add left border");\n    addBorder(totalHeight);\n  } else {\n    skipBorder(totalHeight);\n  }\n  rect2.attr("stroke-dasharray", strokeDashArray.join(" "));\n}\nconst rectWithTitle = (parent, node) => {\n  let classes;\n  if (!node.classes) {\n    classes = "node default";\n  } else {\n    classes = "node " + node.classes;\n  }\n  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const innerLine = shapeSvg.insert("line");\n  const label = shapeSvg.insert("g").attr("class", "label");\n  const text2 = node.labelText.flat ? node.labelText.flat() : node.labelText;\n  let title = "";\n  if (typeof text2 === "object") {\n    title = text2[0];\n  } else {\n    title = text2;\n  }\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Label text abc79", title, text2, typeof text2 === "object");\n  const text = label.node().appendChild(createLabel$1(title, node.labelStyle, true, true));\n  let bbox = { width: 0, height: 0 };\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = text.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(text);\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Text 2", text2);\n  const textRows = text2.slice(1, text2.length);\n  let titleBox = text.getBBox();\n  const descr = label.node().appendChild(\n    createLabel$1(textRows.join ? textRows.join("<br/>") : textRows, node.labelStyle, true, true)\n  );\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = descr.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(descr);\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  const halfPadding = node.padding / 2;\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(descr).attr(\n    "transform",\n    "translate( " + // (titleBox.width - bbox.width) / 2 +\n    (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ", " + (titleBox.height + halfPadding + 5) + ")"\n  );\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(text).attr(\n    "transform",\n    "translate( " + // (titleBox.width - bbox.width) / 2 +\n    (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ", 0)"\n  );\n  bbox = label.node().getBBox();\n  label.attr(\n    "transform",\n    "translate(" + -bbox.width / 2 + ", " + (-bbox.height / 2 - halfPadding + 3) + ")"\n  );\n  rect2.attr("class", "outer title-state").attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  innerLine.attr("class", "divider").attr("x1", -bbox.width / 2 - halfPadding).attr("x2", bbox.width / 2 + halfPadding).attr("y1", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr("y2", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst stadium = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const h = bbox.height + node.padding;\n  const w = bbox.width + h / 4 + node.padding;\n  const rect2 = shapeSvg.insert("rect", ":first-child").attr("style", node.style).attr("rx", h / 2).attr("ry", h / 2).attr("x", -w / 2).attr("y", -h / 2).attr("width", w).attr("height", h);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst circle = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, void 0, true);\n  const circle2 = shapeSvg.insert("circle", ":first-child");\n  circle2.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Circle main");\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Circle intersect", node, bbox.width / 2 + halfPadding, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding, point2);\n  };\n  return shapeSvg;\n};\nconst doublecircle = async (parent, node) => {\n  const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, void 0, true);\n  const gap = 5;\n  const circleGroup = shapeSvg.insert("g", ":first-child");\n  const outerCircle = circleGroup.insert("circle");\n  const innerCircle = circleGroup.insert("circle");\n  outerCircle.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding + gap).attr("width", bbox.width + node.padding + gap * 2).attr("height", bbox.height + node.padding + gap * 2);\n  innerCircle.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node.padding).attr("height", bbox.height + node.padding);\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("DoubleCircle main");\n  updateNodeBounds(node, outerCircle);\n  node.intersect = function(point2) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("DoubleCircle intersect", node, bbox.width / 2 + halfPadding + gap, point2);\n    return intersect.circle(node, bbox.width / 2 + halfPadding + gap, point2);\n  };\n  return shapeSvg;\n};\nconst subroutine = async (parent, node) => {\n  const { shapeSvg, bbox } = await labelHelper(parent, node, void 0, true);\n  const w = bbox.width + node.padding;\n  const h = bbox.height + node.padding;\n  const points = [\n    { x: 0, y: 0 },\n    { x: w, y: 0 },\n    { x: w, y: -h },\n    { x: 0, y: -h },\n    { x: 0, y: 0 },\n    { x: -8, y: 0 },\n    { x: w + 8, y: 0 },\n    { x: w + 8, y: -h },\n    { x: -8, y: -h },\n    { x: -8, y: 0 }\n  ];\n  const el = insertPolygonShape(shapeSvg, w, h, points);\n  el.attr("style", node.style);\n  updateNodeBounds(node, el);\n  node.intersect = function(point2) {\n    return intersect.polygon(node, points, point2);\n  };\n  return shapeSvg;\n};\nconst start = (parent, node) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  const circle2 = shapeSvg.insert("circle", ":first-child");\n  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst forkJoin = (parent, node, dir) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  let width = 70;\n  let height = 10;\n  if (dir === "LR") {\n    width = 10;\n    height = 70;\n  }\n  const shape = shapeSvg.append("rect").attr("x", -1 * width / 2).attr("y", -1 * height / 2).attr("width", width).attr("height", height).attr("class", "fork-join");\n  updateNodeBounds(node, shape);\n  node.height = node.height + node.padding / 2;\n  node.width = node.width + node.padding / 2;\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst end = (parent, node) => {\n  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);\n  const innerCircle = shapeSvg.insert("circle", ":first-child");\n  const circle2 = shapeSvg.insert("circle", ":first-child");\n  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);\n  innerCircle.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10);\n  updateNodeBounds(node, circle2);\n  node.intersect = function(point2) {\n    return intersect.circle(node, 7, point2);\n  };\n  return shapeSvg;\n};\nconst class_box = (parent, node) => {\n  const halfPadding = node.padding / 2;\n  const rowPadding = 4;\n  const lineHeight = 8;\n  let classes;\n  if (!node.classes) {\n    classes = "node default";\n  } else {\n    classes = "node " + node.classes;\n  }\n  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);\n  const rect2 = shapeSvg.insert("rect", ":first-child");\n  const topLine = shapeSvg.insert("line");\n  const bottomLine = shapeSvg.insert("line");\n  let maxWidth = 0;\n  let maxHeight = rowPadding;\n  const labelContainer = shapeSvg.insert("g").attr("class", "label");\n  let verticalPos = 0;\n  const hasInterface = node.classData.annotations && node.classData.annotations[0];\n  const interfaceLabelText = node.classData.annotations[0] ? "«" + node.classData.annotations[0] + "»" : "";\n  const interfaceLabel = labelContainer.node().appendChild(createLabel$1(interfaceLabelText, node.labelStyle, true, true));\n  let interfaceBBox = interfaceLabel.getBBox();\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = interfaceLabel.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(interfaceLabel);\n    interfaceBBox = div.getBoundingClientRect();\n    dv.attr("width", interfaceBBox.width);\n    dv.attr("height", interfaceBBox.height);\n  }\n  if (node.classData.annotations[0]) {\n    maxHeight += interfaceBBox.height + rowPadding;\n    maxWidth += interfaceBBox.width;\n  }\n  let classTitleString = node.classData.label;\n  if (node.classData.type !== void 0 && node.classData.type !== "") {\n    if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels) {\n      classTitleString += "&lt;" + node.classData.type + "&gt;";\n    } else {\n      classTitleString += "<" + node.classData.type + ">";\n    }\n  }\n  const classTitleLabel = labelContainer.node().appendChild(createLabel$1(classTitleString, node.labelStyle, true, true));\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(classTitleLabel).attr("class", "classTitle");\n  let classTitleBBox = classTitleLabel.getBBox();\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n    const div = classTitleLabel.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(classTitleLabel);\n    classTitleBBox = div.getBoundingClientRect();\n    dv.attr("width", classTitleBBox.width);\n    dv.attr("height", classTitleBBox.height);\n  }\n  maxHeight += classTitleBBox.height + rowPadding;\n  if (classTitleBBox.width > maxWidth) {\n    maxWidth = classTitleBBox.width;\n  }\n  const classAttributes = [];\n  node.classData.members.forEach((str) => {\n    const parsedInfo = (0,_svgDraw_0fcc813d_js__WEBPACK_IMPORTED_MODULE_3__.p)(str);\n    let parsedText = parsedInfo.displayText;\n    if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels) {\n      parsedText = parsedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");\n    }\n    const lbl = labelContainer.node().appendChild(\n      createLabel$1(\n        parsedText,\n        parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle,\n        true,\n        true\n      )\n    );\n    let bbox = lbl.getBBox();\n    if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr("width", bbox.width);\n      dv.attr("height", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classAttributes.push(lbl);\n  });\n  maxHeight += lineHeight;\n  const classMethods = [];\n  node.classData.methods.forEach((str) => {\n    const parsedInfo = (0,_svgDraw_0fcc813d_js__WEBPACK_IMPORTED_MODULE_3__.p)(str);\n    let displayText = parsedInfo.displayText;\n    if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels) {\n      displayText = displayText.replace(/</g, "&lt;").replace(/>/g, "&gt;");\n    }\n    const lbl = labelContainer.node().appendChild(\n      createLabel$1(\n        displayText,\n        parsedInfo.cssStyle ? parsedInfo.cssStyle : node.labelStyle,\n        true,\n        true\n      )\n    );\n    let bbox = lbl.getBBox();\n    if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels)) {\n      const div = lbl.children[0];\n      const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(lbl);\n      bbox = div.getBoundingClientRect();\n      dv.attr("width", bbox.width);\n      dv.attr("height", bbox.height);\n    }\n    if (bbox.width > maxWidth) {\n      maxWidth = bbox.width;\n    }\n    maxHeight += bbox.height + rowPadding;\n    classMethods.push(lbl);\n  });\n  maxHeight += lineHeight;\n  if (hasInterface) {\n    let diffX2 = (maxWidth - interfaceBBox.width) / 2;\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(interfaceLabel).attr(\n      "transform",\n      "translate( " + (-1 * maxWidth / 2 + diffX2) + ", " + -1 * maxHeight / 2 + ")"\n    );\n    verticalPos = interfaceBBox.height + rowPadding;\n  }\n  let diffX = (maxWidth - classTitleBBox.width) / 2;\n  (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(classTitleLabel).attr(\n    "transform",\n    "translate( " + (-1 * maxWidth / 2 + diffX) + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"\n  );\n  verticalPos += classTitleBBox.height + rowPadding;\n  topLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classAttributes.forEach((lbl) => {\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(lbl).attr(\n      "transform",\n      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + ")"\n    );\n    verticalPos += classTitleBBox.height + rowPadding;\n  });\n  verticalPos += lineHeight;\n  bottomLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);\n  verticalPos += lineHeight;\n  classMethods.forEach((lbl) => {\n    (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(lbl).attr(\n      "transform",\n      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"\n    );\n    verticalPos += classTitleBBox.height + rowPadding;\n  });\n  rect2.attr("class", "outer title-state").attr("x", -maxWidth / 2 - halfPadding).attr("y", -(maxHeight / 2) - halfPadding).attr("width", maxWidth + node.padding).attr("height", maxHeight + node.padding);\n  updateNodeBounds(node, rect2);\n  node.intersect = function(point2) {\n    return intersect.rect(node, point2);\n  };\n  return shapeSvg;\n};\nconst shapes = {\n  rhombus: question,\n  question,\n  rect,\n  labelRect,\n  rectWithTitle,\n  choice,\n  circle,\n  doublecircle,\n  stadium,\n  hexagon,\n  rect_left_inv_arrow,\n  lean_right,\n  lean_left,\n  trapezoid,\n  inv_trapezoid,\n  rect_right_inv_arrow,\n  cylinder,\n  start,\n  end,\n  note: note$1,\n  subroutine,\n  fork: forkJoin,\n  join: forkJoin,\n  class_box\n};\nlet nodeElems = {};\nconst insertNode = async (elem, node, dir) => {\n  let newEl;\n  let el;\n  if (node.link) {\n    let target;\n    if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().securityLevel === "sandbox") {\n      target = "_top";\n    } else if (node.linkTarget) {\n      target = node.linkTarget || "_blank";\n    }\n    newEl = elem.insert("svg:a").attr("xlink:href", node.link).attr("target", target);\n    el = await shapes[node.shape](newEl, node, dir);\n  } else {\n    el = await shapes[node.shape](elem, node, dir);\n    newEl = el;\n  }\n  if (node.tooltip) {\n    el.attr("title", node.tooltip);\n  }\n  if (node.class) {\n    el.attr("class", "node default " + node.class);\n  }\n  nodeElems[node.id] = newEl;\n  if (node.haveCallback) {\n    nodeElems[node.id].attr("class", nodeElems[node.id].attr("class") + " clickable");\n  }\n  return newEl;\n};\nconst setNodeElem = (elem, node) => {\n  nodeElems[node.id] = elem;\n};\nconst clear$1 = () => {\n  nodeElems = {};\n};\nconst positionNode = (node) => {\n  const el = nodeElems[node.id];\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.trace(\n    "Transforming node",\n    node.diff,\n    node,\n    "translate(" + (node.x - node.width / 2 - 5) + ", " + node.width / 2 + ")"\n  );\n  const padding = 8;\n  const diff = node.diff || 0;\n  if (node.clusterNode) {\n    el.attr(\n      "transform",\n      "translate(" + (node.x + diff - node.width / 2) + ", " + (node.y - node.height / 2 - padding) + ")"\n    );\n  } else {\n    el.attr("transform", "translate(" + node.x + ", " + node.y + ")");\n  }\n  return diff;\n};\nlet edgeLabels = {};\nlet terminalLabels = {};\nconst clear = () => {\n  edgeLabels = {};\n  terminalLabels = {};\n};\nconst insertEdgeLabel = (elem, edge) => {\n  const useHtmlLabels = (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.n)((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels);\n  const labelElement = edge.labelType === "markdown" ? (0,_createText_3df630b5_js__WEBPACK_IMPORTED_MODULE_2__.c)(elem, edge.label, {\n    style: edge.labelStyle,\n    useHtmlLabels,\n    addSvgBackground: true\n  }) : createLabel$1(edge.label, edge.labelStyle);\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("abc82", edge, edge.labelType);\n  const edgeLabel = elem.insert("g").attr("class", "edgeLabel");\n  const label = edgeLabel.insert("g").attr("class", "label");\n  label.node().appendChild(labelElement);\n  let bbox = labelElement.getBBox();\n  if (useHtmlLabels) {\n    const div = labelElement.children[0];\n    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_0__.select)(labelElement);\n    bbox = div.getBoundingClientRect();\n    dv.attr("width", bbox.width);\n    dv.attr("height", bbox.height);\n  }\n  label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");\n  edgeLabels[edge.id] = edgeLabel;\n  edge.width = bbox.width;\n  edge.height = bbox.height;\n  let fo;\n  if (edge.startLabelLeft) {\n    const startLabelElement = createLabel$1(edge.startLabelLeft, edge.labelStyle);\n    const startEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = startEdgeLabelLeft.insert("g").attr("class", "inner");\n    fo = inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startLeft = startEdgeLabelLeft;\n    setTerminalWidth(fo, edge.startLabelLeft);\n  }\n  if (edge.startLabelRight) {\n    const startLabelElement = createLabel$1(edge.startLabelRight, edge.labelStyle);\n    const startEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = startEdgeLabelRight.insert("g").attr("class", "inner");\n    fo = startEdgeLabelRight.node().appendChild(startLabelElement);\n    inner.node().appendChild(startLabelElement);\n    const slBox = startLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].startRight = startEdgeLabelRight;\n    setTerminalWidth(fo, edge.startLabelRight);\n  }\n  if (edge.endLabelLeft) {\n    const endLabelElement = createLabel$1(edge.endLabelLeft, edge.labelStyle);\n    const endEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = endEdgeLabelLeft.insert("g").attr("class", "inner");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    endEdgeLabelLeft.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endLeft = endEdgeLabelLeft;\n    setTerminalWidth(fo, edge.endLabelLeft);\n  }\n  if (edge.endLabelRight) {\n    const endLabelElement = createLabel$1(edge.endLabelRight, edge.labelStyle);\n    const endEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");\n    const inner = endEdgeLabelRight.insert("g").attr("class", "inner");\n    fo = inner.node().appendChild(endLabelElement);\n    const slBox = endLabelElement.getBBox();\n    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");\n    endEdgeLabelRight.node().appendChild(endLabelElement);\n    if (!terminalLabels[edge.id]) {\n      terminalLabels[edge.id] = {};\n    }\n    terminalLabels[edge.id].endRight = endEdgeLabelRight;\n    setTerminalWidth(fo, edge.endLabelRight);\n  }\n  return labelElement;\n};\nfunction setTerminalWidth(fo, value) {\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.htmlLabels && fo) {\n    fo.style.width = value.length * 9 + "px";\n    fo.style.height = "12px";\n  }\n}\nconst positionEdgeLabel = (edge, paths) => {\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("Moving label abc78 ", edge.id, edge.label, edgeLabels[edge.id]);\n  let path = paths.updatedPath ? paths.updatedPath : paths.originalPath;\n  if (edge.label) {\n    const el = edgeLabels[edge.id];\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.u.calcLabelPosition(path);\n      _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info(\n        "Moving label " + edge.label + " from (",\n        x,\n        ",",\n        y,\n        ") to (",\n        pos.x,\n        ",",\n        pos.y,\n        ") abc78"\n      );\n      if (paths.updatedPath) {\n        x = pos.x;\n        y = pos.y;\n      }\n    }\n    el.attr("transform", "translate(" + x + ", " + y + ")");\n  }\n  if (edge.startLabelLeft) {\n    const el = terminalLabels[edge.id].startLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_left", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", "translate(" + x + ", " + y + ")");\n  }\n  if (edge.startLabelRight) {\n    const el = terminalLabels[edge.id].startRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(\n        edge.arrowTypeStart ? 10 : 0,\n        "start_right",\n        path\n      );\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", "translate(" + x + ", " + y + ")");\n  }\n  if (edge.endLabelLeft) {\n    const el = terminalLabels[edge.id].endLeft;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_left", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", "translate(" + x + ", " + y + ")");\n  }\n  if (edge.endLabelRight) {\n    const el = terminalLabels[edge.id].endRight;\n    let x = edge.x;\n    let y = edge.y;\n    if (path) {\n      const pos = _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.u.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_right", path);\n      x = pos.x;\n      y = pos.y;\n    }\n    el.attr("transform", "translate(" + x + ", " + y + ")");\n  }\n};\nconst outsideNode = (node, point2) => {\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(point2.x - x);\n  const dy = Math.abs(point2.y - y);\n  const w = node.width / 2;\n  const h = node.height / 2;\n  if (dx >= w || dy >= h) {\n    return true;\n  }\n  return false;\n};\nconst intersection = (node, outsidePoint, insidePoint) => {\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`intersection calc abc89:\n  outsidePoint: ${JSON.stringify(outsidePoint)}\n  insidePoint : ${JSON.stringify(insidePoint)}\n  node        : x:${node.x} y:${node.y} w:${node.width} h:${node.height}`);\n  const x = node.x;\n  const y = node.y;\n  const dx = Math.abs(x - insidePoint.x);\n  const w = node.width / 2;\n  let r = insidePoint.x < outsidePoint.x ? w - dx : w + dx;\n  const h = node.height / 2;\n  const Q = Math.abs(outsidePoint.y - insidePoint.y);\n  const R = Math.abs(outsidePoint.x - insidePoint.x);\n  if (Math.abs(y - outsidePoint.y) * w > Math.abs(x - outsidePoint.x) * h) {\n    let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;\n    r = R * q / Q;\n    const res = {\n      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,\n      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q\n    };\n    if (r === 0) {\n      res.x = outsidePoint.x;\n      res.y = outsidePoint.y;\n    }\n    if (R === 0) {\n      res.x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      res.y = outsidePoint.y;\n    }\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);\n    return res;\n  } else {\n    if (insidePoint.x < outsidePoint.x) {\n      r = outsidePoint.x - w - x;\n    } else {\n      r = x - w - outsidePoint.x;\n    }\n    let q = Q * r / R;\n    let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;\n    let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, { _x, _y });\n    if (r === 0) {\n      _x = outsidePoint.x;\n      _y = outsidePoint.y;\n    }\n    if (R === 0) {\n      _x = outsidePoint.x;\n    }\n    if (Q === 0) {\n      _y = outsidePoint.y;\n    }\n    return { x: _x, y: _y };\n  }\n};\nconst cutPathAtIntersect = (_points, boundryNode) => {\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("abc88 cutPathAtIntersect", _points, boundryNode);\n  let points = [];\n  let lastPointOutside = _points[0];\n  let isInside = false;\n  _points.forEach((point2) => {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("abc88 checking point", point2, boundryNode);\n    if (!outsideNode(boundryNode, point2) && !isInside) {\n      const inter = intersection(boundryNode, lastPointOutside, point2);\n      _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("abc88 inside", point2, lastPointOutside, inter);\n      _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("abc88 intersection", inter);\n      let pointPresent = false;\n      points.forEach((p) => {\n        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;\n      });\n      if (!points.some((e) => e.x === inter.x && e.y === inter.y)) {\n        points.push(inter);\n      } else {\n        _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("abc88 no intersect", inter, points);\n      }\n      isInside = true;\n    } else {\n      _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("abc88 outside", point2, lastPointOutside);\n      lastPointOutside = point2;\n      if (!isInside) {\n        points.push(point2);\n      }\n    }\n  });\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.warn("abc88 returning points", points);\n  return points;\n};\nconst insertEdge = function(elem, e, edge, clusterDb, diagramType, graph) {\n  let points = edge.points;\n  let pointsHasChanged = false;\n  const tail = graph.node(e.v);\n  var head = graph.node(e.w);\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("abc88 InsertEdge: ", edge);\n  if (head.intersect && tail.intersect) {\n    points = points.slice(1, edge.points.length - 1);\n    points.unshift(tail.intersect(points[0]));\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info(\n      "Last point",\n      points[points.length - 1],\n      head,\n      head.intersect(points[points.length - 1])\n    );\n    points.push(head.intersect(points[points.length - 1]));\n  }\n  if (edge.toCluster) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("to cluster abc88", clusterDb[edge.toCluster]);\n    points = cutPathAtIntersect(edge.points, clusterDb[edge.toCluster].node);\n    pointsHasChanged = true;\n  }\n  if (edge.fromCluster) {\n    _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("from cluster abc88", clusterDb[edge.fromCluster]);\n    points = cutPathAtIntersect(points.reverse(), clusterDb[edge.fromCluster].node).reverse();\n    pointsHasChanged = true;\n  }\n  const lineData = points.filter((p) => !Number.isNaN(p.y));\n  let curve;\n  if (diagramType === "graph" || diagramType === "flowchart") {\n    curve = edge.curve || d3__WEBPACK_IMPORTED_MODULE_0__.curveBasis;\n  } else {\n    curve = d3__WEBPACK_IMPORTED_MODULE_0__.curveBasis;\n  }\n  const lineFunction = (0,d3__WEBPACK_IMPORTED_MODULE_0__.line)().x(function(d) {\n    return d.x;\n  }).y(function(d) {\n    return d.y;\n  }).curve(curve);\n  let strokeClasses;\n  switch (edge.thickness) {\n    case "normal":\n      strokeClasses = "edge-thickness-normal";\n      break;\n    case "thick":\n      strokeClasses = "edge-thickness-thick";\n      break;\n    case "invisible":\n      strokeClasses = "edge-thickness-thick";\n      break;\n    default:\n      strokeClasses = "";\n  }\n  switch (edge.pattern) {\n    case "solid":\n      strokeClasses += " edge-pattern-solid";\n      break;\n    case "dotted":\n      strokeClasses += " edge-pattern-dotted";\n      break;\n    case "dashed":\n      strokeClasses += " edge-pattern-dashed";\n      break;\n  }\n  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", edge.id).attr("class", " " + strokeClasses + (edge.classes ? " " + edge.classes : "")).attr("style", edge.style);\n  let url = "";\n  if ((0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().flowchart.arrowMarkerAbsolute || (0,_mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.c)().state.arrowMarkerAbsolute) {\n    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;\n    url = url.replace(/\\(/g, "\\\\(");\n    url = url.replace(/\\)/g, "\\\\)");\n  }\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("arrowTypeStart", edge.arrowTypeStart);\n  _mermaid_b0ad2de1_js__WEBPACK_IMPORTED_MODULE_1__.l.info("arrowTypeEnd", edge.arrowTypeEnd);\n  switch (edge.arrowTypeStart) {\n    case "arrow_cross":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-crossStart)");\n      break;\n    case "arrow_point":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-pointStart)");\n      break;\n    case "arrow_barb":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-barbStart)");\n      break;\n    case "arrow_circle":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-circleStart)");\n      break;\n    case "aggregation":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-aggregationStart)");\n      break;\n    case "extension":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-extensionStart)");\n      break;\n    case "composition":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-compositionStart)");\n      break;\n    case "dependency":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-dependencyStart)");\n      break;\n    case "lollipop":\n      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-lollipopStart)");\n      break;\n  }\n  switch (edge.arrowTypeEnd) {\n    case "arrow_cross":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-crossEnd)");\n      break;\n    case "arrow_point":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-pointEnd)");\n      break;\n    case "arrow_barb":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-barbEnd)");\n      break;\n    case "arrow_circle":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-circleEnd)");\n      break;\n    case "aggregation":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-aggregationEnd)");\n      break;\n    case "extension":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-extensionEnd)");\n      break;\n    case "composition":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-compositionEnd)");\n      break;\n    case "dependency":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-dependencyEnd)");\n      break;\n    case "lollipop":\n      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-lollipopEnd)");\n      break;\n  }\n  let paths = {};\n  if (pointsHasChanged) {\n    paths.updatedPath = points;\n  }\n  paths.originalPath = edge.points;\n  return paths;\n};\n\n\n\n//# sourceURL=webpack://frontend/./node_modules/mermaid/dist/edges-49ac43a2.js?')}}]);